===
= MUSE programmer's guide
===

MUSE stands for "maximally uncomplicated scripting environment". the
goal of MUSE is to enable scripts to manipulate data while achieving
as small code size as possible. the small code size requirement
applies to the sum of the script code and to the interpreter that will
be required to execute it. therefore, it is intended for the language
to be "simple" while enabling complex operations to be expressed
compactly.

the virtual architecture includes a single register "r", a variable
stack "s" on which variables can be allocated, and a data memory
"m". the variable stack is separate from data memory (i.e., variables
on the stack cannot be accessed through memory operations).

the basic construct supported by the MUSE programming language is a
"pipe". a pipe is formed of a "pull" followed by any number of unary
or binary operations. the register "r" is used as the output and input
of every pipe stage. at the end of the pipe, "r" will have the value
generated by the last operator.

a pipe pull may be the current register value "r". this costs nothing,
as "r" is what is used as the input for pipe operator stages anyways.

a pipe pull may be a constant chosen from among a limited set of
possible constant values (e.g., from among 0, -1, or +1). in this
case, the pipe pull stage consists of loading the constant into "r".

a pipe pull may be a variable. in this case, the pipe pull stage
consists of loading the variable into "r".

a pipe operation may be a unary operator. in this case, "r" is set to
the result of applying the unary operator on "r". available unary
operators include:

CLR or 0     ::: r = 0
UNI or 1     ::: r = 1

SET or -1    ::: r = -1

DRF or []    ::: r = m[r]

RVB          ::: r = (reverse bits of r)
RVY          ::: r = (reverse bytes of r)

DTB          ::: r = ("detonate" bits of r)
DTY          ::: r = ("detonate" bytes of r)

SLS          ::: r = (zero-based index of least significant bit set in r, or -1 if (r == 0))
SMS          ::: r = (zero-based index of most significant bit set in r, or -1 if (r == 0))

EXP          ::: r = (1<<r)
LOG          ::: r = (smallest q such that (r <= (1<<q)) under unsigned comparison, or -1 if not satisfiable)

INV or ~     ::: r = ~r
NEG or 0-    ::: r = -r
INC or ++    ::: r = r+1
DEC or --    ::: r = r-1

RS1 or >>1   ::: r = r>>1 (arithmetic)
RS2 or >>2   ::: r = r>>2 (arithmetic)
RS3 or >>3   ::: r = r>>3 (arithmetic)
RS4 or >>4   ::: r = r>>4 (arithmetic)

LS1 or <<1   ::: r = r<<1
LS2 or <<2   ::: r = r<<2
LS3 or <<3   ::: r = r<<3
LS4 or <<4   ::: r = r<<4

a pipe operation may also be a binary operator. in this case, it must
be followed by a variable "v". available binary operators include:

rMOV    ,     ::: r = v;
rIND or []<== ::: m[r] = v;

rAND or &     ::: r &= v;
rIOR or |     ::: r |= v;
rXOR or ^     ::: r ^= v;

rADD or +     ::: r += v;
rSUB or -     ::: r -= v;

rSHL or <<    ::: r <<= v;
rSAR or >>    ::: r >>= v; (arithmetic)
rSLR or >>>   ::: r >>>= v; (logical)
rSRR or >>>>  ::: r >>>>= v; (rotate)

vMOV    =     ::: v = r;
vIND or ==>[] ::: m[v] = r;

vAND or =&    ::: v &= r;
vIOR or =|    ::: v |= r;
vXOR or =^    ::: v ^= r;

vADD or =+    ::: v += r;
vSUB or =-    ::: v -= r;

vSHL or =<<   ::: v <<= r;
vSAR or =>>   ::: v >>= r; (arithmetic)
rSLR or =>>>  ::: v >>>= r; (logical)
rSRR or =>>>> ::: v >>>>= r; (rotate)

of the binary operators listed above, rMOV, rIND and vIND are
unconventional. rMOV would supplant the value of "r" with the value of
the right-hand-side variable, essentially performing a pipe
pull. indeed, a pipe pull is implemented as an rMOV. there is no
reason to explicitly issue a rMOV, since pipes can be joined using the
comma operator. for this reason, rMOV has no shorthand. rIND writes
the value of the right-hand-side variable to the memory word
referenced by "r", and sets "r" to that value also. vIND writes the
value of "r" to the memory word referenced by the right-hand-side
variable (thus leaving "r" unchanged).

thus a pipe can read memory through DRF (operator "[]") and write
memory through rIND or vIND (operators "[]<==" and "==>[]").

an integer expression consists of one or more pipes, joined by comma
operators. the value of an integer expression is the value of "r" at
the end of the last pipe.

an initializer expression is slightly more general than an integer
expression: the pipe pull is permitted to be an arbitrary constant.

a conditional expression consists of a condition followed by an
integer expression. the condition is applied to the value of the
integer expression. available conditions include:

AW - always jump
NW - never jump

EZ - true iff (r == 0)
NZ - true iff (r != 0)

SP - true iff (r > 0)    [signed comparison]
NP - true iff (!(r > 0)) [signed comparison]

SN - true iff (r < 0)    [signed comparison]
NN - true iff (!(r < 0)) [signed comparison]

MUSE supports high-level programming; i.e., scoping constructs.

to declare a function:

.frame (name) %arg1 %arg2 %argN
{
}

which declares arg1, arg2 and argN to exist on the stack (below a
return address) inside the block (which is function body).

to declare a scope:

.scope (name) %var1 = ini1 ; %var2 = ini2 ; ... ; %varN = iniN
{
  body
}

which allocates the named variables on the stack and assigns to each
the value of the assocated initializer expression before executing the
body.

to express an if statement:

.if (condition) (expression)
{
  body1
}
.else
{
  body2
}

to express a while loop:

.while (name) (condition) (expression)
{
  body
}

which repeatedly tests the condition and executes body if the
condition is true.

to express a for loop:

.for (name) %varI = ini1 ; (condition) (expression) ; (increment expression)
{
  body
}

which is equivalent to:

.scope %varI = ini1
{
  .while (condition) (expression)
  {
    body
    (increment expression)
  }
}

all named scoping constructs enable .break (name) and .continue (name)
which may be invoked from within those scopes. ambiguity is resolved
by choosing the innermost match. break exists the scope while continue
reruns it (which begins with a condition test in the case of while).
